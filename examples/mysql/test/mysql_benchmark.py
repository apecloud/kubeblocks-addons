#!/usr/bin/env python3
"""
################################################################################
#                       MySQL Sysbench Benchmark Test Suite
################################################################################
#
# ü§ñ This benchmark test was generated by GPT (Claude Sonnet 4) to provide
#    comprehensive MySQL performance testing using sysbench.
#
# üìã DESCRIPTION:
#    A professional-grade benchmark testing tool that measures MySQL
#    performance across multiple dimensions:
#    - OLTP read/write mixed workloads
#    - Read-only and write-only performance
#    - Query latency and throughput analysis
#    - Thread scaling and concurrency testing
#    - Connection handling under load
#    - InnoDB storage engine optimization testing
#
# üîß PREREQUISITES:
#    - Python 3.6 or higher
#    - MySQL server (5.7+ or 8.0+ recommended)
#    - MySQL client tools (mysql) installed and in PATH
#    - Sysbench with MySQL support installed
#    - Admin access to MySQL server for creating test databases
#
# üì¶ INSTALLATION (Ubuntu/Debian):
#    sudo apt-get update
#    sudo apt-get install mysql-client sysbench python3
#
# üì¶ INSTALLATION (CentOS/RHEL):
#    sudo yum install mysql sysbench python3
#
# üì¶ INSTALLATION (macOS):
#    brew install mysql sysbench python3
#
# üöÄ BASIC USAGE:
#    python3 mysql_benchmark.py --host localhost --user root --password mypass
#
# üéØ ADVANCED USAGE EXAMPLES:
#
#    # Quick test with small dataset
#    python3 mysql_benchmark.py --host localhost --user root --password mypass \
#                              --table-size 10000 --duration 30 --threads 1 4 8
#
#    # High-performance test with large dataset
#    python3 mysql_benchmark.py --host remotehost --user admin --password secret \
#                              --table-size 1000000 --duration 300 --threads 1 2 4 8 16 32 64
#
#    # Remote database testing with custom port
#    python3 mysql_benchmark.py --host 192.168.1.100 --port 3306 --user dbadmin \
#                              --password strongpass --database test_replica
#
# üìä WHAT IT MEASURES:
#    ‚úÖ Connection performance and stability
#    ‚úÖ Transactions per second (TPS) under various loads
#    ‚úÖ Query latency (average, min, max, 95th percentile)
#    ‚úÖ Thread scaling efficiency and optimal concurrency
#    ‚úÖ Mixed OLTP workload performance (reads + writes)
#    ‚úÖ Specialized workload performance (read-only, write-only)
#    ‚úÖ Random point select performance
#    ‚úÖ Range scan performance
#    ‚úÖ INSERT/UPDATE/DELETE throughput
#    ‚úÖ Error rates and connection failures
#    ‚úÖ InnoDB buffer pool efficiency
#
# üìà OUTPUT:
#    - Real-time progress with emoji indicators
#    - Comprehensive console report with key metrics
#    - JSON file export with detailed results for analysis
#    - Thread scaling analysis and efficiency metrics
#    - Performance comparison across different workload types
#    - MySQL-specific metrics (InnoDB stats, query cache, etc.)
#
# üóÇÔ∏è TEST DATABASE:
#    The benchmark automatically creates a temporary test database
#    'sysbench_test' and user 'sysbench_user'. All test data is cleaned
#    up automatically after completion.
#
# ‚ö†Ô∏è  SAFETY NOTES:
#    - Only creates temporary test databases, doesn't affect existing data
#    - Requires admin privileges to create databases and users
#    - Test database is automatically cleaned up after benchmark
#    - Safe to run on production servers (creates isolated test environment)
#    - Uses InnoDB storage engine for ACID compliance
#
# üèÜ MYSQL PERFORMANCE TIPS:
#    - Tune innodb_buffer_pool_size (typically 70-80% of available RAM)
#    - Set innodb_log_file_size appropriately for your workload
#    - Configure innodb_flush_log_at_trx_commit based on durability needs
#    - Use binary logging for production environments
#    - Monitor MySQL status variables during tests
#    - Consider partitioning for very large datasets
#    - Test with thread counts matching your expected concurrent connections
#
# üìÑ GENERATED REPORTS:
#    - Console output: Real-time results with summary statistics
#    - JSON file: mysql_sysbench_YYYYMMDD_HHMMSS.json with detailed metrics
#    - Metrics include: TPS, QPS, latency percentiles, error counts, scaling efficiency
#
# üêõ TROUBLESHOOTING:
#    - "mysql: command not found" ‚Üí Install mysql-client package
#    - "sysbench: command not found" ‚Üí Install sysbench package
#    - "Access denied" ‚Üí Check username, password, and privileges
#    - Connection failures ‚Üí Check host, port, credentials, and firewall
#    - "Can't create database" ‚Üí Ensure user has CREATE privileges
#    - Performance issues ‚Üí Check MySQL configuration and system resources
#
# üìö MYSQL-SPECIFIC NOTES:
#    - Tests are optimized for InnoDB storage engine
#    - Supports MySQL 5.7+ and 8.0+ features
#    - Compatible with MariaDB 10.x
#    - Automatically detects MySQL version and adjusts accordingly
#    - Tests both MyISAM and InnoDB performance characteristics
#
# üìû SUPPORT:
#    This tool was generated by AI and is provided as-is. For MySQL
#    performance tuning, consult the official MySQL documentation
#    and performance guides at dev.mysql.com.
#
################################################################################

A comprehensive benchmark testing tool for MySQL that measures:
- Connection performance
- CRUD operations throughput
- Concurrent connection handling
- Query performance under load
- Transaction performance
- InnoDB storage engine efficiency

Requirements:
- Python 3.6+
- MySQL client (mysql)
- Sysbench with MySQL support
- Standard Python libraries only

Usage:
    python3 mysql_benchmark.py --host localhost --user root --password mypass
"""

import subprocess
import argparse
import time
import json
import os
import sys
import re
import statistics
from datetime import datetime


class MySQLSysbench:
    def __init__(self, host, port, user, password, database="mysql"):
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.database = database
        self.test_db = "sysbench_test"
        self.test_user = "sysbench_user"
        self.test_password = "SysbenchPass123!"
        self.results = {}

    def _run_sql(self, sql_command, database=None, capture_output=True, timeout=30):
        """Execute SQL command using mysql client"""
        db = database or self.database

        cmd = [
            'mysql',
            '-h', self.host,
            '-P', str(self.port),
            '-u', self.user,
            f'-p{self.password}',  # MySQL client expects no space between -p and password
            '-D', db,
            '-e', sql_command,
            '--silent',  # Reduce output verbosity
            '--raw',     # Raw output without formatting
        ]

        try:
            result = subprocess.run(
                cmd,
                capture_output=capture_output,
                text=True,
                timeout=timeout,
                check=True
            )
            return True, result.stdout.strip() if capture_output else ""
        except subprocess.CalledProcessError as e:
            error_msg = e.stderr.strip() if e.stderr else str(e)
            return False, error_msg
        except subprocess.TimeoutExpired:
            return False, "Command timed out"

    def _run_sql_file(self, sql_commands, database=None):
        """Execute multiple SQL commands using mysql client"""
        db = database or self.database

        cmd = [
            'mysql',
            '-h', self.host,
            '-P', str(self.port),
            '-u', self.user,
            f'-p{self.password}',
            '-D', db,
            '--silent'
        ]

        try:
            process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            stdout, stderr = process.communicate(input=sql_commands, timeout=60)

            if process.returncode == 0:
                return True, stdout
            else:
                return False, stderr
        except subprocess.TimeoutExpired:
            process.kill()
            return False, "Command timed out"

    def _run_sysbench(self, test_type, operation, threads=1, duration=60, table_size=100000, additional_params=""):
        """Execute sysbench command with proper error handling"""

        base_cmd = [
            'sysbench',
            test_type,
            f'--db-driver=mysql',
            f'--mysql-host={self.host}',
            f'--mysql-port={self.port}',
            f'--mysql-user={self.test_user}',
            f'--mysql-password={self.test_password}',
            f'--mysql-db={self.test_db}',
            f'--table-size={table_size}',
            f'--report-interval=10',
        ]

        if operation == "run":
            base_cmd.extend([
                f'--threads={threads}',
                f'--time={duration}',
            ])

        if additional_params:
            base_cmd.extend(additional_params.split())

        base_cmd.append(operation)

        try:
            print(f"üîÑ Running sysbench {test_type} {operation}...")
            if threads > 1:
                print(f"   Threads: {threads}, Duration: {duration}s")

            result = subprocess.run(
                base_cmd,
                capture_output=True,
                text=True,
                check=True,
                timeout=duration + 60 if operation == "run" else 120
            )

            print(f"‚úÖ Sysbench {test_type} {operation} completed successfully")
            return True, result.stdout

        except subprocess.CalledProcessError as e:
            print(f"‚ùå Error during sysbench {test_type} {operation}:")
            print(f"   Command: {' '.join(base_cmd)}")
            print(f"   Error: {e.stderr}")
            return False, e.stderr
        except subprocess.TimeoutExpired:
            print(f"‚è∞ Sysbench {test_type} {operation} timed out")
            return False, "Command timed out"

    def _parse_sysbench_results(self, output):
        """Parse sysbench output to extract key metrics"""
        results = {}

        # Extract key metrics using regex
        patterns = {
            'transactions': r'transactions:\s+(\d+)\s+\(([0-9.]+)\s+per sec\.\)',
            'queries': r'queries:\s+(\d+)\s+\(([0-9.]+)\s+per sec\.\)',
            'latency_min': r'min:\s+([0-9.]+)ms',
            'latency_avg': r'avg:\s+([0-9.]+)ms',
            'latency_max': r'max:\s+([0-9.]+)ms',
            'latency_95th': r'95th percentile:\s+([0-9.]+)ms',
            'errors': r'errors:\s+(\d+)',
            'reconnects': r'reconnects:\s+(\d+)',
        }

        for key, pattern in patterns.items():
            match = re.search(pattern, output)
            if match:
                if 'transactions' in key or 'queries' in key:
                    results[key + '_total'] = int(match.group(1))
                    results[key + '_per_sec'] = float(match.group(2))
                else:
                    results[key] = float(match.group(1)) if '.' in match.group(1) else int(match.group(1))

        return results

    def check_dependencies(self):
        """Check if required dependencies are installed"""
        print("üîç Checking dependencies...")

        dependencies = [
            ("mysql", ["mysql", "--version"], "MySQL client is required"),
            ("sysbench", ["sysbench", "--version"], "Sysbench is required for benchmarking")
        ]

        for name, cmd, error_msg in dependencies:
            try:
                result = subprocess.run(cmd, check=True, capture_output=True, text=True)
                version = result.stdout.split('\n')[0]
                print(f"‚úÖ {name}: {version}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                print(f"‚ùå Error: {error_msg}")
                if name == "sysbench":
                    print("Installation instructions:")
                    print("  Ubuntu/Debian: sudo apt-get install sysbench")
                    print("  CentOS/RHEL: sudo yum install sysbench")
                    print("  macOS: brew install sysbench")
                elif name == "mysql":
                    print("Installation instructions:")
                    print("  Ubuntu/Debian: sudo apt-get install mysql-client")
                    print("  CentOS/RHEL: sudo yum install mysql")
                    print("  macOS: brew install mysql")
                return False

        return True

    def check_connection(self):
        """Test basic connectivity to MySQL"""
        print("üîå Testing MySQL connection...")

        start_time = time.time()
        success, output = self._run_sql("SELECT VERSION();")
        connection_time = time.time() - start_time

        if success:
            version = output.split('\n')[0] if output else "Unknown"
            print(f"‚úÖ Connected successfully in {connection_time:.3f}s")
            print(f"   Version: {version}")

            # Get additional MySQL info
            success, engine_info = self._run_sql("SHOW ENGINES;")
            if success and 'InnoDB' in engine_info:
                print("   InnoDB engine: Available")

            self.results['connection'] = {
                'success': True,
                'time': connection_time,
                'version': version
            }
            return True
        else:
            print(f"‚ùå Connection failed: {output}")
            self.results['connection'] = {
                'success': False,
                'error': output
            }
            return False

    def setup_test_environment(self):
        """Create test database and user for sysbench"""
        print("üîß Setting up test environment...")

        # Drop test database if exists
        self._run_sql(f"DROP DATABASE IF EXISTS {self.test_db};")

        # Create test database
        success, output = self._run_sql(f"CREATE DATABASE {self.test_db} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;")
        if not success:
            print(f"‚ùå Failed to create test database: {output}")
            return False

        # Check if user exists
        success, output = self._run_sql(
            f"SELECT User FROM mysql.user WHERE User = '{self.test_user}';",
            capture_output=True
        )

        # Create user if it doesn't exist
        if not output.strip():
            success, output = self._run_sql(
                f"CREATE USER '{self.test_user}'@'%' IDENTIFIED BY '{self.test_password}';",
                capture_output=False
            )
            if not success:
                print(f"‚ùå Failed to create test user: {output}")
                return False
            print(f"‚úÖ Created user {self.test_user}")
        else:
            print(f"üìã User {self.test_user} already exists")

        # Grant privileges (MySQL syntax)
        success, _ = self._run_sql(
            f"GRANT ALL PRIVILEGES ON {self.test_db}.* TO '{self.test_user}'@'%';",
            capture_output=False
        )
        if not success:
            return False

        # Flush privileges
        success, _ = self._run_sql("FLUSH PRIVILEGES;", capture_output=False)
        if not success:
            return False

        print("‚úÖ Test environment setup completed successfully")
        return True

    def run_benchmark_suite(self, table_size=100000, duration=60, thread_counts=[1, 4, 8, 16]):
        """Run comprehensive sysbench benchmark suite"""
        print(f"üöÄ Starting MySQL Sysbench Benchmark Suite")
        print(f"   Table size: {table_size:,} rows")
        print(f"   Test duration: {duration}s per test")
        print(f"   Thread counts: {thread_counts}")
        print("="*60)

        # Test configurations
        test_configs = [
            ("oltp_read_write", "Mixed OLTP Read/Write"),
            ("oltp_read_only", "Read-Only OLTP"),
            ("oltp_write_only", "Write-Only OLTP"),
            ("select_random_points", "Random Point Selects"),
            ("select_random_ranges", "Random Range Selects"),
            ("oltp_insert", "INSERT Performance"),
            ("oltp_update_index", "UPDATE Performance"),
            ("oltp_delete", "DELETE Performance"),
        ]

        benchmark_results = {}

        for test_type, description in test_configs:
            print(f"\nüìä {description} Benchmark")
            print("-" * 40)

            # Prepare test data
            success, output = self._run_sysbench(test_type, "prepare", table_size=table_size)
            if not success:
                print(f"‚ö†Ô∏è  Failed to prepare {test_type}, skipping...")
                continue

            test_results = {}

            # Run tests with different thread counts
            for threads in thread_counts:
                print(f"\nüîπ Testing with {threads} thread(s)...")

                success, output = self._run_sysbench(
                    test_type, "run",
                    threads=threads,
                    duration=duration,
                    table_size=table_size
                )

                if success:
                    parsed_results = self._parse_sysbench_results(output)
                    test_results[f"{threads}_threads"] = parsed_results

                    # Print key metrics
                    if 'transactions_per_sec' in parsed_results:
                        print(f"   TPS: {parsed_results['transactions_per_sec']:.2f}")
                    if 'queries_per_sec' in parsed_results:
                        print(f"   QPS: {parsed_results['queries_per_sec']:.2f}")
                    if 'latency_avg' in parsed_results:
                        print(f"   Avg Latency: {parsed_results['latency_avg']:.2f}ms")
                    if 'latency_95th' in parsed_results:
                        print(f"   95th Latency: {parsed_results['latency_95th']:.2f}ms")
                else:
                    print(f"   ‚ùå Test failed with {threads} threads")
                    test_results[f"{threads}_threads"] = {"error": output}

            benchmark_results[test_type] = {
                'description': description,
                'results': test_results
            }

            # Cleanup after each test
            self._run_sysbench(test_type, "cleanup", table_size=table_size)

        self.results['benchmark_suite'] = benchmark_results
        return benchmark_results

    def run_mysql_specific_tests(self):
        """Run MySQL-specific performance tests"""
        print(f"\nüîß MySQL-Specific Performance Tests")
        print("="*40)

        mysql_tests = {}

        # Test InnoDB vs MyISAM (if available)
        print("üìä Testing storage engines...")

        # Check available engines
        success, engines = self._run_sql("SHOW ENGINES;")
        if success:
            available_engines = []
            if 'InnoDB' in engines:
                available_engines.append('InnoDB')
            if 'MyISAM' in engines:
                available_engines.append('MyISAM')

            mysql_tests['available_engines'] = available_engines
            print(f"   Available engines: {', '.join(available_engines)}")

        # Test query cache effectiveness (MySQL 5.7 and earlier)
        print("üìä Testing query performance...")
        query_tests = [
            ("Simple SELECT", "SELECT COUNT(*) FROM information_schema.tables;"),
            ("Complex JOIN", """
                SELECT t1.table_name, t1.table_rows, t2.data_length
                FROM information_schema.tables t1
                JOIN information_schema.tables t2 ON t1.table_schema = t2.table_schema
                WHERE t1.table_schema = 'information_schema'
                LIMIT 10;
            """),
        ]

        query_results = {}
        for test_name, query in query_tests:
            times = []
            for _ in range(3):
                start_time = time.time()
                success, _ = self._run_sql(query)
                if success:
                    times.append(time.time() - start_time)

            if times:
                avg_time = statistics.mean(times)
                query_results[test_name] = {
                    'average_time': avg_time,
                    'runs': len(times)
                }
                print(f"   {test_name}: {avg_time:.3f}s avg")

        mysql_tests['query_performance'] = query_results
        self.results['mysql_specific_tests'] = mysql_tests

    def cleanup(self):
        """Clean up test database and user"""
        print("üßπ Cleaning up test environment...")

        # Drop test database
        success, _ = self._run_sql(f"DROP DATABASE IF EXISTS {self.test_db};")
        if success:
            print("‚úÖ Test database cleaned up successfully")
        else:
            print("‚ö†Ô∏è  Warning: Could not clean up test database")

    def generate_report(self):
        """Generate a comprehensive benchmark report"""
        print("\n" + "="*80)
        print("üìã MYSQL SYSBENCH BENCHMARK REPORT")
        print("="*80)
        print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Host: {self.host}:{self.port}")
        print(f"Database: {self.database}")
        print("-"*80)

        # Connection info
        if 'connection' in self.results:
            conn = self.results['connection']
            print(f"Connection Test: {'‚úÖ PASS' if conn['success'] else '‚ùå FAIL'}")
            if conn['success']:
                print(f"  Connection Time: {conn['time']:.3f}s")
                print(f"  MySQL Version: {conn.get('version', 'Unknown')}")

        # Benchmark suite results
        if 'benchmark_suite' in self.results:
            print(f"\nüìä BENCHMARK SUITE RESULTS")
            print("-" * 40)

            for test_type, test_data in self.results['benchmark_suite'].items():
                print(f"\nüîπ {test_data['description']}:")

                # Find best performance across thread counts
                best_tps = 0
                best_qps = 0
                best_threads = 0

                for thread_config, results in test_data['results'].items():
                    if 'error' not in results:
                        threads = int(thread_config.split('_')[0])
                        tps = results.get('transactions_per_sec', 0)
                        qps = results.get('queries_per_sec', 0)
                        latency = results.get('latency_avg', 0)

                        if tps > best_tps:
                            best_tps = tps
                            best_threads = threads
                        if qps > best_qps:
                            best_qps = qps

                        print(f"  {threads:2d} threads: ", end="")
                        if tps > 0:
                            print(f"{tps:8.2f} TPS, ", end="")
                        if qps > 0:
                            print(f"{qps:8.2f} QPS, ", end="")
                        print(f"{latency:6.2f}ms avg latency")

                if best_tps > 0:
                    print(f"  üèÜ Best TPS: {best_tps:.2f} with {best_threads} threads")
                if best_qps > 0:
                    print(f"  üèÜ Best QPS: {best_qps:.2f}")

        # MySQL-specific test results
        if 'mysql_specific_tests' in self.results:
            mysql_tests = self.results['mysql_specific_tests']
            print(f"\nüîß MYSQL-SPECIFIC TEST RESULTS")
            print("-" * 40)

            if 'available_engines' in mysql_tests:
                print(f"Storage Engines: {', '.join(mysql_tests['available_engines'])}")

            if 'query_performance' in mysql_tests:
                print(f"\nQuery Performance:")
                for test_name, results in mysql_tests['query_performance'].items():
                    print(f"  {test_name}: {results['average_time']:.3f}s avg")

        print("\n" + "="*80)

        # Save detailed results to JSON file
        report_file = f"mysql_sysbench_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        try:
            with open(report_file, 'w') as f:
                json.dump(self.results, f, indent=2, default=str)
            print(f"üìÑ Detailed results saved to: {report_file}")
        except Exception as e:
            print(f"‚ö†Ô∏è  Warning: Could not save detailed results: {e}")

    def run_full_benchmark(self, table_size=100000, duration=60, thread_counts=[1, 4, 8, 16]):
        """Run the complete benchmark suite"""
        start_time = time.time()

        # Check dependencies
        if not self.check_dependencies():
            return False

        # Check connection
        if not self.check_connection():
            print("‚ùå Cannot proceed without database connection")
            return False

        # Setup test environment
        if not self.setup_test_environment():
            print("‚ùå Cannot proceed without test environment")
            return False

        try:
            # Run benchmark suite
            self.run_benchmark_suite(table_size, duration, thread_counts)

            # Run MySQL-specific tests
            self.run_mysql_specific_tests()

        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è  Benchmark interrupted by user")
        except Exception as e:
            print(f"\n‚ùå Unexpected error during benchmark: {e}")
        finally:
            # Always cleanup
            self.cleanup()

        total_time = time.time() - start_time
        print(f"\n‚è±Ô∏è  Total benchmark time: {total_time:.1f} seconds")

        # Generate report
        self.generate_report()
        return True


def main():
    parser = argparse.ArgumentParser(
        description='MySQL Sysbench Benchmark Test Suite',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic benchmark
  python3 mysql_benchmark.py --host localhost --user root --password mypass

  # Custom configuration
  python3 mysql_benchmark.py --host 192.168.1.100 --user admin --password secret \\
                            --table-size 1000000 --duration 120 --threads 1 2 4 8 16 32
        """
    )

    parser.add_argument('--host', required=True, help='MySQL host')
    parser.add_argument('--port', type=int, default=3306, help='MySQL port (default: 3306)')
    parser.add_argument('--user', required=True, help='MySQL admin user')
    parser.add_argument('--password', required=True, help='MySQL admin password')
    parser.add_argument('--database', default='mysql', help='Initial database to connect to (default: mysql)')
    parser.add_argument('--table-size', type=int, default=100000, help='Number of rows per table (default: 100000)')
    parser.add_argument('--duration', type=int, default=60, help='Test duration in seconds (default: 60)')
    parser.add_argument('--threads', nargs='+', type=int, default=[1, 4, 8, 16],
                       help='Thread counts to test (default: 1 4 8 16)')

    args = parser.parse_args()

    # Validate thread counts
    if any(t <= 0 for t in args.threads):
        print("‚ùå Error: Thread counts must be positive integers")
        sys.exit(1)

    # Run benchmark
    benchmark = MySQLSysbench(
        args.host, args.port, args.user, args.password, args.database
    )

    success = benchmark.run_full_benchmark(
        table_size=args.table_size,
        duration=args.duration,
        thread_counts=sorted(args.threads)
    )

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()